---
title: cpp
description: 
published: true
date: 2022-03-31T17:44:29.105Z
tags: 
editor: markdown
dateCreated: 2022-03-11T07:55:15.284Z
---

# C++
# Приведение типов {.tabset}

https://habr.com/ru/post/106294/

## static_cast

`Type static_cast<Type> (object);`

`static_cast` преобразует выражения одного статического типа в объекты и значения другого статического типа. Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз. Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки.

## dynamic_cast

`Type& dynamic_cast<Type&> (object);`
`Type* dynamic_cast<Type*> (object);`

Используется для динамического приведения типов во время выполнения. В случае неправильного приведения типов для ссылок вызывается исключительная ситуация `std::bad_cast`, а для указателей будет возвращен 0. Использует систему RTTI (Runtime Type Information). Безопасное приведение типов по иерархии наследования, в том числе для виртуального наследования.

Основное назначение `dynamic_cast` - защита от нисходящего приведения типов в тех случаях, когда это лишено смысла. Например, если у вас есть ссылка или указатель на базовый класс, но вы точно знаете, что на самом деле она указывает на экземпляр производного типа, вы можете выполнить приведение и работать с производным типом.
Это называется нисходящее приведение. Но если там будет объект базового типа, лишенный своей производной части, такое приведение лишено смысла и приведет к неопределенному поведению.

## const_cast

`Type const_cast<Type> (object);`

Пожалуй самое простое приведение типов. Снимает cv qualifiers — const и volatile, то есть константность и отказ от оптимизации компилятором переменной. Это преобразование проверяется на уровне компиляции и в случае ошибки приведения типов будет выдано сообщение.

## reinterpret_cast

`Type reinterpret_cast<Type> (object);`

Приведение типов без проверки. `reinterpret_cast` — непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Не снимает константность и `volatile`. применяется для приведения указателя к указателю, указателя к целому и наоборот.

## C-style cast

`Type (Type*) object;`

Си-шный метод приведения типов. Пожалуй самый нежелательный способ приведения типов. Страуструп пишет:
«Например, что это значит выражение — x = (T)y;. Мы не знаем. Это зависит от типа T, типов x и y. T может быть названием типа, typedef или может быть параметр template-а. Может быть, х и у являются скалярными переменными и Т представляет собой значение преобразования. Может быть, х объекта класса, производного от класса Y и Т — нисходящее преобразование. По этой причине программист может не знать, что он делает на самом деле.»
Вторая причина нежелательного использования приведения типов в C-style — трудоемкость процесса поиска мест приведения типов.

# Умные указатели

## std::unique_ptr

Это умный указатель, который владеет и управляет другим объектом через указатель и удаляет этот объект, когда unique_ptr выходит за пределы области видимости.

Объект удаляется с использованием асоциированного удаления (associated deleter), когда происходит одно из следующих событий:

- управляющий объект unique_ptr уничтожается;
- управляющему объекту unique_ptr назначается другой указатель с помощью operator= или reset().

https://en.cppreference.com/w/cpp/memory/unique_ptr

## std::shared_ptr

В отличие от `std::unique_ptr`, который предназначен для единоличного владения и управления переданным ему ресурсом/объектом, `std::shared_ptr` предназначен для случаев, когда несколько умных указателей совместно владеют одним динамически выделенным ресурсом.

Объект уничтожается, а его память освобождается, когда происходит одно из следующих событий:
- последний оставшийся shared_ptr, владеющий объектом, уничтожается;
- последнему оставшемуся shared_ptr, владеющему объектом, назначается другой указатель с помощью operator= или reset().

https://en.cppreference.com/w/cpp/memory/shared_ptr

## std::weak_ptr

`std::weak_ptr` — это умный указатель, который содержит ссылку, не являющуюся владельцем («слабую»), на объект, которым управляет `std::shared_ptr`. Его необходимо преобразовать в `std::shared_ptr`, чтобы получить доступ к указанному объекту.

`std::weak_ptr` моделирует временное владение: когда к объекту нужно получить доступ, только если он существует, и он может быть удален в любое время кем-то другим, `std::weak_ptr` используется для отслеживания объекта и преобразуется в `std::shared_ptr` для временного владения. Если в это время исходный `std::shared_ptr` уничтожается, время жизни объекта продлевается до тех пор, пока не будет уничтожен временный `std::shared_ptr`.

Еще одно применение `std::weak_ptr` — прерывание циклической зависимости, сформированных объектами, управляемыми `std::shared_ptr`. Если такой цикл осиротел (т. е. в цикле нет внешних общих указателей), счетчик ссылок `std::shared_ptr` не может достичь нуля, и происходит утечка памяти. Чтобы этого не произошло, один из указателей в цикле можно сделать `std::weak_ptr` («слабым»).

https://en.cppreference.com/w/cpp/memory/weak_ptr

## Пример использования

TODO

# l-values и r-values

В языке C++ все переменные являются l-values. l-value — это значение, которое имеет свой собственный адрес в памяти. Поскольку все переменные имеют адреса, то они все являются l-values. l от слова «left», так как только значения l-values могут находиться в левой стороне в операциях присваивания (в противном случае, мы получим ошибку). Например, стейтмент 9 = 10; вызовет ошибку компилятора, так как 9 не является l-value. Число 9 не имеет своего адреса в памяти и, таким образом, мы ничего не можем ему присвоить (9 = 9 и ничего здесь не изменить).

Противоположностью l-value является r-value. r-value — это значение, которое не имеет постоянного адреса в памяти. Примерами могут быть единичные числа (например, 7, которое имеет значение 7) или выражения (например, 3 + х, которое имеет значение х плюс 3).

# Мультипоточность

## std::atomic

## std::mutex

## rdlock rwlock

## spinlock

## semaphore

## barrier

https://en.cppreference.com/w/cpp/atomic/atomic

# Мутабельность mutable

https://habr.com/ru/company/infopulse/blog/341264/

TODO

# RAII (Resource Acquisition Is Initialization)

TODO

https://habr.com/ru/post/150069/

# Частичная специлизация шаблонов & SFINAE

TODO

# Минимальный размер класса и виртуального класса

Минимальный размер класса равен 1. По стандарту размер класса(структуры) не может быть равен 0, т.к. будет нарушаться расчёт адреса в памяти по смещению.

Минимальный размер виртуального клсса равен размеру указателя в системе(на 64x это 8). Т.к. Это размер vtable(виртуальной таблицы).

https://www.stroustrup.com/bs_faq2.html#sizeof-empty


# links
