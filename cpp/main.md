---
title: cpp
description: 
published: true
date: 2022-03-11T10:41:06.492Z
tags: 
editor: markdown
dateCreated: 2022-03-11T07:55:15.284Z
---

# C++
# Приведение типов

## static_cast

`Type static_cast<Type> (object);`

`static_cast` преобразует выражения одного статического типа в объекты и значения другого статического типа. Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз. Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки.

## dynamic_cast

`Type& dynamic_cast<Type&> (object);`
`Type* dynamic_cast<Type*> (object);`

Используется для динамического приведения типов во время выполнения. В случае неправильного приведения типов для ссылок вызывается исключительная ситуация `std::bad_cast`, а для указателей будет возвращен 0. Использует систему RTTI (Runtime Type Information). Безопасное приведение типов по иерархии наследования, в том числе для виртуального наследования.

Основное назначение `dynamic_cast` - защита от нисходящего приведения типов в тех случаях, когда это лишено смысла. Например, если у вас есть ссылка или указатель на базовый класс, но вы точно знаете, что на самом деле она указывает на экземпляр производного типа, вы можете выполнить приведение и работать с производным типом.
Это называется нисходящее приведение. Но если там будет объект базового типа, лишенный своей производной части, такое приведение лишено смысла и приведет к неопределенному поведению.

## const_cast.

`Type const_cast<Type> (object);`

Пожалуй самое простое приведение типов. Снимает cv qualifiers — const и volatile, то есть константность и отказ от оптимизации компилятором переменной. Это преобразование проверяется на уровне компиляции и в случае ошибки приведения типов будет выдано сообщение.

## reinterpret_cast

`Type reinterpret_cast<Type> (object);`

Приведение типов без проверки. `reinterpret_cast` — непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Не снимает константность и `volatile`. применяется для приведения указателя к указателю, указателя к целому и наоборот.

## C-style cast

`Type (Type*) object;`

Си-шный метод приведения типов. Пожалуй самый нежелательный способ приведения типов. Страуструп пишет:
«Например, что это значит выражение — x = (T)y;. Мы не знаем. Это зависит от типа T, типов x и y. T может быть названием типа, typedef или может быть параметр template-а. Может быть, х и у являются скалярными переменными и Т представляет собой значение преобразования. Может быть, х объекта класса, производного от класса Y и Т — нисходящее преобразование. По этой причине программист может не знать, что он делает на самом деле.»
Вторая причина нежелательного использования приведения типов в C-style — трудоемкость процесса поиска мест приведения типов.

# Умные указатели

## `std::unique_ptr`

Это умный указатель, который владеет и управляет другим объектом через указатель и удаляет этот объект, когда unique_ptr выходит за пределы области видимости.

Объект удаляется с использованием асоциированного удаления (associated deleter), когда происходит одно из следующих событий:

- управляющий объект unique_ptr уничтожается;
- управляющему объекту unique_ptr назначается другой указатель с помощью operator= или reset().

# l-values и r-values

В языке C++ все переменные являются l-values. l-value — это значение, которое имеет свой собственный адрес в памяти. Поскольку все переменные имеют адреса, то они все являются l-values. l от слова «left», так как только значения l-values могут находиться в левой стороне в операциях присваивания (в противном случае, мы получим ошибку). Например, стейтмент 9 = 10; вызовет ошибку компилятора, так как 9 не является l-value. Число 9 не имеет своего адреса в памяти и, таким образом, мы ничего не можем ему присвоить (9 = 9 и ничего здесь не изменить).

Противоположностью l-value является r-value. r-value — это значение, которое не имеет постоянного адреса в памяти. Примерами могут быть единичные числа (например, 7, которое имеет значение 7) или выражения (например, 3 + х, которое имеет значение х плюс 3).

# links
[Приведение типов](https://habr.com/ru/post/106294/)
