# MAKEFILE

средство автоматизации сборки приложений

простейший рецепт, который по команде make исполнит gcc test.c

```
all:
    gcc test.c
```

## Запуск make внутри make

Правильным вариантом является запуск `$(MAKE)`, а не `make`, при этом передаются все флаги от родителя, в т.ч. флаг `-j`.

```
all:
    $(MAKE) -f ./config.mk
```

## Справка по ключам

- `-j 5` or `-j5` вызов сборки в несколько потоков, в данном случае 5
- `-C /opt/project/mira` указать директорию в которой следует искать `Makefile`
- `-f` указать полный путь до make файла

## Автоматические переменные

`$@`
    Имя файла цели правила. Если цель является элементом архива (archive member), то `$@` обозначает имя архивного файла. В шаблонном правиле с несколькими целями (смотрите раздел Введение в шаблонные правила), `$@' обозначает имя цели, которая вызывала запуск команд данного правила.

`$%`
    Для целей, являющихся элементами архива, обозначает имя этого элемента. Смотрите раздел Использование make для обновления архивов. Например, для цели `foo.a(bar.o)` переменная `$%` принимает значение `bar.o`, а переменная `$@` - значение `foo.a`. Если цель не является элементом архива, `$%` имеет пустое значение.

`$<`
    Имя первого пререквизита. В случае, если выполняемые команды относятся к неявному правилу, первым пререквизитом является тот, который был указан в неявном правиле. (смотрите раздел Использование неявных правил).

`$?`
    Имена всех пререквизитов (разделенные пробелами), которые являются "более новыми", чем цель. Для членов архива, используется имя самого элемента (смотрите раздел Использование make для обновления архивов).

`$^`
    Имена всех пререквизитов (разделенные пробелами). Для пререквизитов, которые являются элементами архивов, используются только имена элементов (смотрите раздел Использование make для обновления архивов). Независимого от того, сколько раз конкретный файл был указан в списке пререквизитов, цель будет иметь только одну зависимость от этого файла. Таким образом, если в списке пререквизитов одно и то же имя файла будет фигурировать несколько раз, переменная $^ все равно будет содержать только одну копию этого имени.

`$+`
    Аналогично `$^', но пререквизиты, перечисленные более, чем один раз, также будут продублированы (в том порядке, как они были указаны в make-файле). В основном, эта переменная может быть полезна в командах компоновки, где порядок следования библиотек и их возможное дублирование является существенным.

`$*`
    Основа (stem), с которой было сопоставлено неявное правило (смотрите раздел Процедура сопоставления с шаблоном). Например, для цели `dir/a.foo.b` и шаблона цели `a.%.b`, основой будет строка `dir/foo`. Основа имени может быть полезной для конструирования имен взаимосвязанных файлов. В статическом шаблонном правиле, основой является часть имени файла, соотвествующая символу `%` в шаблоне цели. Для явного правила такое определение неприменимо, поэтому `$*` вычисляется по-другому. В случае явного правила, если имя цели имеет один из "известных" суффиксов (смотрите раздел Устаревшие суффиксные правила), в переменную `$*` записывается имя цели без этого суффикса. Например, для цели `foo.c`, переменная `$*` будет установлена в `foo`, поскольку `.c` является одним из "известных" суффиксов. Программа GNU make поступает столь причудливым образом лишь по соображениям совместимости с другими версиями make. Мы рекомендуем вам избегать использования переменной `$*` где-либо, кроме неявных или статических шаблонных правил. В случае, если цель явного правила не имеет один известных make суффиксов, для данного правила значением переменной `$*` является пустая строка.

## Простой Универсальный Makefile

```makefile
.PHONY: all                  # специальная цель для целей не файлов. Требуется чтобы make не спутал цель с файлом
CC=g++                       # выбираем компилятор
INCLUDE=-I../include         # дополнительные папки, где будет производиться поиск #include
CFLAGS=$(INCLUDE) -c -Wall   # флаги компиляции
LDFLAGS=-L/usr/lib/Qt -lQtSql# флаги линковки. -L папка поиска библиотек. -l сама либа
SOURCES=main.cpp hello.cpp factorial.cpp
OBJECTS=$(SOURCES:.cpp=.o)   # файлы для компиляции
EXECUTABLE=hello             # итоговый файл

# начальная цель может быть с любым названием
all: $(EXECUTABLE) # зависимости цели

$(EXECUTABLE): $(OBJECTS)
	$(CC) $(LDFLAGS) $(OBJECTS) -o $@

# специальная цель которая соотносит файлы cpp и o
.cpp.o: 
	$(CC) $(CFLAGS) $< -o $@

clean:
    rm -f $(EXECUTABLE) $(OBJECTS)
```

## Ссылки

[расширенный мануал](http://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html#SEC101)